import cats.effect.IOApp
import cats.effect.IO
import cats.implicits.*
import fs2.Stream
import utils.readInput
import cats.syntax.all.*

sealed trait Tile:
  val pos: Int
  val row: Int

case class PartNum(n: Int, pos: Int, end: Int, row: Int) extends Tile
case class Symbol(c: Char, pos: Int, row: Int) extends Tile
case class Empty(pos: Int, row: Int) extends Tile

def buildGrid(input: Stream[IO, String]) =
  input.zipWithIndex
    .map((line, idx) =>
      val numRegex = "(\\d+)".r
      val symRegex = "([^.\\d])".r

      val nums = numRegex
        .findAllMatchIn(line)
        .map(n => PartNum(n.matched.toInt, n.start, n.end - 1, idx.toInt))
        .toList
        .sortBy(_.pos)

      val syms = symRegex
        .findAllMatchIn(line)
        .map(n => Symbol(n.matched(0), n.start, idx.toInt))

      // val blanks = line.zipWithIndex
      //   .filter(_._1 == '.')
      //   .map(p => Empty(p._2))

      (nums ++ syms).sortBy(_.pos)
    )
    .foldMonoid
    .flatMap(x => Stream.emits(x))

def tileIsValid(tile: PartNum, syms: Vector[Symbol]) =
  syms
    .filter(s =>
      val firstCond = s.pos == tile.pos - 1 ||
        s.pos == tile.end + 1 ||
        (s.pos >= tile.pos - 1 && s.pos <= tile.end + 1)

      val secondCond = s.row >= tile.row - 1 && s.row <= tile.row + 1

      firstCond && secondCond
    )
    .nonEmpty

def part1(grid: IO[Vector[Tile]]) =
  grid
    .map(tiles =>
      val numberTiles =
        tiles.filter(_.isInstanceOf[PartNum]).asInstanceOf[Vector[PartNum]]
      val symTiles =
        tiles.filter(_.isInstanceOf[Symbol]).asInstanceOf[Vector[Symbol]]

      numberTiles
        .map(tile => if tileIsValid(tile, symTiles) then tile.n else 0)
        .sum
    )

def part2(grid: IO[Vector[Tile]]): Stream[IO, Int] =

object Day03 extends IOApp.Simple:
  override def run: IO[Unit] =
    val input = readInput("Day03")
    val grid = buildGrid(input).compile.toVector

    part1(grid) >>= IO.println
